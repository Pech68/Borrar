<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Divisor Contable Pro (con OCR)</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Librerías Principales -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    
    <!-- Tesseract.js para OCR (Lectura de imágenes) -->
    <script src='https://unpkg.com/tesseract.js@4.1.1/dist/tesseract.min.js'></script>

    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap" rel="stylesheet">
    
    <style>
        body { font-family: 'Inter', sans-serif; }
        .fade-in { animation: fadeIn 0.3s ease-out forwards; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
        /* Barra de progreso personalizada */
        progress::-webkit-progress-bar { background-color: #e2e8f0; border-radius: 999px; }
        progress::-webkit-progress-value { background-color: #3b82f6; border-radius: 999px; transition: width 0.3s ease; }
    </style>
</head>
<body class="bg-gray-50 text-slate-800">

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        
        // Configurar PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // --- Iconos ---
        const IconScan = () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M3 10h18M3 14h18m-9-4v8m-7 0h14a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>;
        const IconBolt = () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>;

        function App() {
            const [file, setFile] = useState(null);
            const [processing, setProcessing] = useState(false);
            const [progress, setProgress] = useState(0);
            const [currentStatus, setCurrentStatus] = useState("");
            const [splitFiles, setSplitFiles] = useState([]);
            const [logs, setLogs] = useState([]);
            
            // Configuración
            const [useOCR, setUseOCR] = useState(true); // Por defecto OCR activado para escaneos
            const [keyword, setKeyword] = useState("COMPROBANTE");
            const [prefix, setPrefix] = useState("No"); // Flexible: buscará "No", "No.", "N°"

            const addLog = (msg) => {
                const time = new Date().toLocaleTimeString();
                setLogs(prev => [`[${time}] ${msg}`, ...prev]);
                setCurrentStatus(msg);
            };

            const handleFile = (e) => {
                if(e.target.files[0]) {
                    setFile(e.target.files[0]);
                    setSplitFiles([]);
                    setLogs([]);
                    setProgress(0);
                }
            };

            // --- Función Mágica de OCR ---
            const extractTextWithOCR = async (pdfPage, pageNum) => {
                try {
                    // 1. Renderizar página a Canvas
                    const viewport = pdfPage.getViewport({ scale: 1.5 }); // Escala alta para leer mejor
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    
                    // OPTIMIZACIÓN: Solo leer el 35% superior de la página (donde está el título)
                    // Esto reduce el tiempo de proceso de 5 seg a 1.5 seg por página.
                    const cropHeight = viewport.height * 0.35; 
                    
                    canvas.height = cropHeight;
                    canvas.width = viewport.width;

                    await pdfPage.render({
                        canvasContext: context,
                        viewport: viewport,
                        // El transform recorta la visualización
                    }).promise;

                    // 2. Usar Tesseract en el Canvas
                    const { data: { text } } = await Tesseract.recognize(canvas, 'spa', {
                        // logger: m => console.log(m) // Descomentar para ver progreso interno de Tesseract
                    });
                    
                    return text;
                } catch (e) {
                    console.error("Error OCR en pag " + pageNum, e);
                    return "";
                }
            };

            const processPDF = async () => {
                if (!file) return;
                setProcessing(true);
                setLogs([]);
                setSplitFiles([]);
                setProgress(0);

                try {
                    const arrayBuffer = await file.arrayBuffer();
                    // Clonar buffer para pdf-lib (crítico)
                    const bufferCopy = arrayBuffer.slice(0);
                    
                    const loadingTask = pdfjsLib.getDocument(arrayBuffer);
                    const pdfTextDoc = await loadingTask.promise;
                    const numPages = pdfTextDoc.numPages;
                    
                    const { PDFDocument } = PDFLib;
                    const pdfDoc = await PDFDocument.load(bufferCopy);

                    addLog(`Iniciando análisis de ${numPages} páginas en modo ${useOCR ? 'OCR (Escaneado)' : 'Texto Nativo'}...`);

                    const groups = []; 
                    let currentGroup = null;

                    // Regex más agresiva para encontrar números dispersos
                    // Busca la palabra clave, luego cualquier cosa, luego el prefijo, luego digitos
                    // Ej: coincide con "COMPROBANTE ... basura ... No. ... 850"
                    // const headerRegex = new RegExp(`${keyword}[\\s\\S]{0,200}?${prefix}[^0-9]{0,10}(\\d+)`, 'i');
                    
                    // Regex simple para buscar el número independientemente de la palabra clave primero
                    // Buscamos "No 850" o "No. 850" o "850" si está cerca de la palabra clave
                    const numberRegex = /(\d+)/;

                    for (let i = 1; i <= numPages; i++) {
                        // Actualizar progreso
                        setProgress(Math.round(((i - 1) / numPages) * 100));
                        
                        const page = await pdfTextDoc.getPage(i);
                        let pageText = "";

                        if (useOCR) {
                            addLog(`Escaneando página ${i}/${numPages} (OCR)...`);
                            pageText = await extractTextWithOCR(page, i);
                        } else {
                            // Modo rápido (texto seleccionable)
                            const textContent = await page.getTextContent();
                            pageText = textContent.items.map(item => item.str).join(' ');
                        }

                        // Normalización: Quitar saltos de línea y espacios extraños
                        const cleanText = pageText.replace(/\n/g, ' ').replace(/\s+/g, ' ').toUpperCase();
                        const keywordFound = cleanText.includes(keyword.toUpperCase());
                        
                        // Lógica de detección mejorada
                        if (keywordFound) {
                            // Intentar encontrar el número cerca del prefijo
                            // Buscamos algo como "No 850" o "No. 850"
                            const prefixIndex = cleanText.indexOf(prefix.toUpperCase());
                            let noteNumber = "Desconocido_" + i;

                            if (prefixIndex !== -1) {
                                // Cortar el texto después del prefijo y buscar el primer número
                                const textAfterPrefix = cleanText.substring(prefixIndex);
                                const match = textAfterPrefix.match(/(\d+)/);
                                if (match) noteNumber = match[1];
                            } else {
                                // Si no hay prefijo "No", buscar el primer numero después de la keyword
                                const textAfterKeyword = cleanText.substring(cleanText.indexOf(keyword.toUpperCase()));
                                const match = textAfterKeyword.match(/(\d+)/);
                                if (match) noteNumber = match[1];
                            }

                            addLog(`--> Pág ${i}: NUEVA NOTA detectada (#${noteNumber})`);
                            
                            currentGroup = {
                                id: noteNumber,
                                pageIndices: [i - 1]
                            };
                            groups.push(currentGroup);

                        } else {
                            // Es una página de anexo/soporte
                            if (currentGroup) {
                                // addLog(`Pág ${i}: Soporte de nota ${currentGroup.id}`);
                                currentGroup.pageIndices.push(i - 1);
                            } else {
                                // Caso especial: primera página sin título
                                addLog(`Pág ${i}: Sin cabecera (asignando a Inicio)`);
                                if (groups.length === 0 || groups[groups.length-1].id !== 'Indefinido') {
                                    currentGroup = { id: 'Indefinido', pageIndices: [i - 1] };
                                    groups.push(currentGroup);
                                } else {
                                    currentGroup.pageIndices.push(i - 1);
                                }
                            }
                        }
                    }

                    setProgress(100);
                    addLog(`Análisis completo. Generando ${groups.length} archivos PDF...`);

                    // Generar PDFs
                    const generatedFiles = [];
                    for (const group of groups) {
                        const newPdf = await PDFDocument.create();
                        const copiedPages = await newPdf.copyPages(pdfDoc, group.pageIndices);
                        copiedPages.forEach(page => newPdf.addPage(page));
                        
                        const pdfBytes = await newPdf.save();
                        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                        
                        generatedFiles.push({
                            name: `${group.id}.pdf`,
                            blob: blob,
                            pages: group.pageIndices.length
                        });
                    }

                    setSplitFiles(generatedFiles);
                    addLog("¡Listo! Archivos preparados para descarga.");

                } catch (error) {
                    console.error(error);
                    addLog(`ERROR: ${error.message}`);
                    alert("Ocurrió un error. Revisa que el PDF sea válido.");
                } finally {
                    setProcessing(false);
                }
            };

            const downloadZip = async () => {
                const zip = new JSZip();
                splitFiles.forEach(file => zip.file(file.name, file.blob));
                const content = await zip.generateAsync({ type: "blob" });
                saveAs(content, "Notas_Separadas_OCR.zip");
            };

            return (
                <div className="min-h-screen p-4 md:p-10 max-w-5xl mx-auto">
                    
                    {/* Header */}
                    <div className="text-center mb-10">
                        <h1 className="text-3xl font-extrabold text-slate-900 tracking-tight">
                            Divisor de Notas Contables <span className="text-blue-600">Pro</span>
                        </h1>
                        <p className="text-slate-500 mt-2">
                            Separa archivos escaneados o digitales automáticamente.
                        </p>
                    </div>

                    <div className="grid md:grid-cols-3 gap-6">
                        
                        {/* Columna Izquierda: Configuración */}
                        <div className="md:col-span-1 space-y-4">
                            <div className="bg-white p-5 rounded-xl shadow-sm border border-slate-200">
                                <label className="block text-sm font-semibold text-slate-700 mb-2">1. Cargar Archivo</label>
                                <div className="border-2 border-dashed border-slate-300 rounded-lg p-6 text-center hover:bg-slate-50 transition cursor-pointer relative">
                                    <input type="file" accept=".pdf" onChange={handleFile} className="absolute inset-0 opacity-0 cursor-pointer" />
                                    <div className="text-blue-500 mx-auto mb-2"><IconScan /></div>
                                    <span className="text-xs text-slate-500">{file ? file.name : "Click para subir PDF"}</span>
                                </div>
                            </div>

                            <div className="bg-white p-5 rounded-xl shadow-sm border border-slate-200">
                                <label className="block text-sm font-semibold text-slate-700 mb-3">2. Modo de Lectura</label>
                                
                                <div className="space-y-3">
                                    <button 
                                        onClick={() => setUseOCR(false)}
                                        className={`w-full flex items-center p-3 rounded-lg border text-sm transition ${!useOCR ? 'border-blue-500 bg-blue-50 text-blue-700' : 'border-slate-200 hover:bg-slate-50'}`}
                                    >
                                        <div className="mr-3"><IconBolt /></div>
                                        <div className="text-left">
                                            <div className="font-semibold">Modo Rápido</div>
                                            <div className="text-[10px] opacity-70">Si el PDF permite seleccionar texto.</div>
                                        </div>
                                    </button>

                                    <button 
                                        onClick={() => setUseOCR(true)}
                                        className={`w-full flex items-center p-3 rounded-lg border text-sm transition ${useOCR ? 'border-purple-500 bg-purple-50 text-purple-700' : 'border-slate-200 hover:bg-slate-50'}`}
                                    >
                                        <div className="mr-3"><IconScan /></div>
                                        <div className="text-left">
                                            <div className="font-semibold">Modo Escaneado (OCR)</div>
                                            <div className="text-[10px] opacity-70">Para imágenes/scans. Más lento pero efectivo.</div>
                                        </div>
                                    </button>
                                </div>
                            </div>

                            <button 
                                onClick={processPDF}
                                disabled={!file || processing}
                                className={`w-full py-3 px-4 rounded-xl font-bold text-white shadow-lg transition-all transform active:scale-95
                                    ${!file || processing ? 'bg-slate-400 cursor-not-allowed' : 'bg-gradient-to-r from-blue-600 to-purple-600 hover:shadow-xl'}
                                `}
                            >
                                {processing ? 'Procesando...' : 'Comenzar Separación'}
                            </button>
                        </div>

                        {/* Columna Derecha: Resultados y Log */}
                        <div className="md:col-span-2 space-y-6">
                            
                            {/* Panel de Progreso */}
                            <div className="bg-slate-900 text-green-400 p-4 rounded-xl font-mono text-xs h-64 overflow-y-auto shadow-inner flex flex-col-reverse">
                                {logs.length === 0 && <div className="text-slate-600 text-center mt-10">Esperando inicio del proceso...</div>}
                                {logs.map((log, i) => <div key={i} className="border-l-2 border-slate-700 pl-2 mb-1">{log}</div>)}
                            </div>

                            {processing && (
                                <div className="space-y-1">
                                    <div className="flex justify-between text-xs font-semibold text-slate-600">
                                        <span>Progreso</span>
                                        <span>{progress}%</span>
                                    </div>
                                    <progress value={progress} max="100" className="w-full h-2"></progress>
                                    <p className="text-xs text-center text-slate-500 animate-pulse">{currentStatus}</p>
                                </div>
                            )}

                            {/* Resultados */}
                            {splitFiles.length > 0 && (
                                <div className="bg-white rounded-xl shadow border border-slate-200 p-6 fade-in">
                                    <div className="flex justify-between items-center mb-4">
                                        <h3 className="font-bold text-lg text-slate-800">Archivos Generados ({splitFiles.length})</h3>
                                        <button onClick={downloadZip} className="bg-green-600 text-white px-4 py-2 rounded-lg text-sm font-semibold hover:bg-green-700 shadow-md flex gap-2">
                                            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
                                            Descargar ZIP
                                        </button>
                                    </div>
                                    <div className="grid grid-cols-2 sm:grid-cols-3 gap-3 max-h-60 overflow-y-auto pr-2">
                                        {splitFiles.map((f, i) => (
                                            <div key={i} className="flex flex-col bg-slate-50 p-3 rounded border border-slate-100 text-center">
                                                <span className="font-bold text-slate-700 text-sm truncate">{f.name}</span>
                                                <span className="text-xs text-slate-500">{f.pages} pág(s)</span>
                                                <div className="flex gap-1 mt-2 justify-center">
                                                     <button 
                                                        onClick={() => window.open(URL.createObjectURL(f.blob))}
                                                        className="px-2 py-1 bg-white border border-slate-300 rounded text-[10px] hover:bg-slate-100"
                                                    >Ver</button>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}

                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
